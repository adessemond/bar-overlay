diff -ur iscsitarget-1.4.20.2/ChangeLog iscsitarget-trunk-r453/ChangeLog
--- iscsitarget-1.4.20.2/ChangeLog	2010-07-15 11:15:46.761307000 -0400
+++ iscsitarget-trunk-r453/ChangeLog	2011-03-20 17:59:31.006005000 -0400
@@ -1,10 +1,17 @@
-Summary of changes from v1.4.20.1 to v1.4.20.2
+Summary of changes from v1.4.20 to Current
 =================================
 Arne Redlich
+  o adapt backward compat mechanism in Makefile to kernels >= 2.6.33
   o uninitialized data fixes pointed out by valgrind
   o fix invalid read in iSNS code pointed out by valgrind
+  o Fixed iSNS initialization issue, thanks to majianpeng@gmail.com
+  o The NIPQUAD macro has been removed, instead "%pI4" is used
+  o Converted semaphores to mutexes
+  o Fixed printing IPv4 addresses in /proc/net/iet/session for kernels >= 2.6.33
+  o Fixed block device handling for kernels >= 2.6.38
 
 Ross Walker
+  o restore SCSI SN behaviour of IET < 1.4.20 (VMWare compatibility)
   o check buffer boundaries in iSNS code (CVE-2010-2221)
   o fix memleak in iSNS ACL code
   o clean up iSCSI login response error handling
@@ -12,15 +19,33 @@
   o fix soft lockup during UA allocation
   o change DISTDIR to DESTDIR
   o avoid deletion of targets with active sessions
-  o byte swap fix in MD5 / SHA1 code (thanks to Harshal Shete for testing on PPC)
+  o byte swap fix in MD5 / SHA1 code
+  o Updated initd scripts to reflect PID file name change
+  o Removed stray RPM build dependency on openssl from spec file
+  o Fixed crypto API error handling (ERR_PTR instead of a NULL)
+  o Fixed small memory leak in volume args buffer on BSD
+  o Fixed io context handling on kernels >= 2.6.25
+  o Fixed max_cmd_sn not being set for the session
+  o Fixed issue where StatSN was being updated when a command was ignored
+  o Fixed connection accounting in ietd for session reinstatements
+  o Fixed MaxOutStandingR2T handling
+  o Stripped zone id off ipv6 addresses in SendTargets
+  o Time2Retain fixed at 0 since it isn't implemented
 
-Summary of changes from v1.4.20 to v1.4.20.1
-=================================
-Arne Redlich
-  o adapt backward compat mechanism in Makefile to kernels >= 2.6.33
+Chris Siebenmann, Wido den Hollander
+  o 2.6.36 compile fix
 
-Ross Walker
-  o restore SCSI SN behaviour of IET < 1.4.20 (VMWare compatibility)
+Craig
+  o Makefile respects LDFLAGS
+
+Jason Zhang
+  o Fixed re-enabling listening after max connections was exceeded
+  o Fix NULL-pointer dereference due to race in UA handling
+
+Martin Hicks
+  o Added variable for depmod
+  o Don't install kernel module executable
+  o Don't use bash for initd script
 
 Summary of changes from v1.4.19 to v1.4.20
 =================================
diff -ur iscsitarget-1.4.20.2/Makefile iscsitarget-trunk-r453/Makefile
--- iscsitarget-1.4.20.2/Makefile	2010-06-29 17:58:35.767759000 -0400
+++ iscsitarget-trunk-r453/Makefile	2011-05-23 15:24:57.968362000 -0400
@@ -9,6 +9,8 @@
 
 #export KSRC := /usr/src/linux
 
+DEPMOD = depmod
+
 SUBDIRS := $(shell pwd)
 
 ifeq ($(KSRC),)
@@ -26,7 +28,7 @@
   endif
 endif
 
-KVER := $(shell $(CC) $(CFLAGS) -E -dM $(VERSION_FILE) | \
+KVER := $(shell $(CC) $(CFLAGS) $(LDFLAGS) -E -dM $(VERSION_FILE) | \
 	grep UTS_RELEASE | awk '{ print $$3 }' | sed 's/\"//g')
 
 KMOD := /lib/modules/$(KVER)/extra
@@ -56,6 +58,19 @@
 # base first the earlier patch sets will not need to be modified.
 #
 
+ifeq ($(call kver_le,2,6,38),1)
+	PATCHES := $(PATCHES) compat-2.6.38.patch
+endif
+
+ifeq ($(call kver_le,2,6,37),1)
+	PATCHES := $(PATCHES) compat-2.6.36-2.6.37.patch
+endif
+
+# Compatibility patch for kernels > 2.6.32 <= 2.6.35
+ifeq ($(call kver_le,2,6,35),1)
+	PATCHES := $(PATCHES) compat-2.6.33-2.6.35.patch
+endif
+
 # Compatibility patch for kernels <= 2.6.32
 ifeq ($(call kver_le,2,6,32),1)
 	PATCHES := $(PATCHES) compat-2.6.32.patch
@@ -210,9 +225,9 @@
 depmod:
 	@echo "Running depmod"
 	@if [ x$(DESTDIR) != x -o x$(INSTALL_MOD_PATH) != x ]; then \
-		depmod -aq -b $(DESTDIR)$(INSTALL_MOD_PATH) $(KVER); \
+		$(DEPMOD) -aq -b $(DESTDIR)$(INSTALL_MOD_PATH) $(KVER); \
 	else \
-		depmod -aq $(KVER); \
+		$(DEPMOD) -aq $(KVER); \
 	fi
 
 install-files: install-usr install-etc install-doc install-kernel
@@ -231,7 +246,7 @@
 				-execdir mv \{\} \{\}.orig \;; \
 		fi \
 	fi
-	@install -vD kernel/iscsi_trgt.ko \
+	@install -vD -m 644 kernel/iscsi_trgt.ko \
 		$(DESTDIR)$(INSTALL_MOD_PATH)$(KMOD)/iscsi/iscsi_trgt.ko
 
 install-usr: usr/ietd usr/ietadm
diff -ur iscsitarget-1.4.20.2/RELEASE_NOTES iscsitarget-trunk-r453/RELEASE_NOTES
--- iscsitarget-1.4.20.2/RELEASE_NOTES	2010-07-15 11:15:46.761307000 -0400
+++ iscsitarget-trunk-r453/RELEASE_NOTES	2011-03-16 17:57:18.706205000 -0400
@@ -2,6 +2,31 @@
                Release Notes for iSCSI Enterprise Target
                =========================================
 
+                            March 18th, 2011
+                            Version 1.4.20.3
+                            ----------------
+
+The IET development team is pleased to announce the release of version
+1.4.20.3 of the iSCSI Enterprise Target.
+
+This release is a bugfix release. The following issues were fixed:
+- multiple compatibility updates to bring kernel support up to 2.6.38
+- fixed iSNS issue that prevented IET from registering
+- fixed re-enabling listening after max connections was exceeded
+- fixed NULL-pointer dereference due to race in UA handling
+- fixed initd scripts to reflect pid file name change
+- fixed crypto API error handling
+- fixed small memory leak in volume args buffer on BSD platforms
+- fixed max_cmd_sn not being set for the session
+- fixed issue where StatSN was being updated when a command was ignored
+- fixed connection accounting in ietd for session reinstatements
+- MaxOutStandingR2T fixed at 1 for 1.4.20 branch due to broken handling
+- fixed ipv6 address handling in SendTargets
+
+               =========================================
+               Release Notes for iSCSI Enterprise Target
+               =========================================
+
                             July 14th, 2010
                             Version 1.4.20.2
                             ----------------
diff -ur iscsitarget-1.4.20.2/dkms.conf iscsitarget-trunk-r453/dkms.conf
--- iscsitarget-1.4.20.2/dkms.conf	2010-07-15 11:15:46.761307000 -0400
+++ iscsitarget-trunk-r453/dkms.conf	2011-03-16 17:57:18.706205000 -0400
@@ -3,7 +3,7 @@
 #
 
 PACKAGE_NAME="iscsitarget"
-PACKAGE_VERSION="1.4.20.2"
+PACKAGE_VERSION="trunk"
 MOD_PATH=${dkms_tree}/${PACKAGE_NAME}/${PACKAGE_VERSION}
 
 BUILT_MODULE_NAME="iscsi_trgt"
@@ -20,42 +20,48 @@
 # Patches newest - oldest, distro spec at bottom
 #
 
-PATCH[0]="compat-2.6.32.patch"
-PATCH_MATCH[0]="2\.6\.(9|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31|32)"
+PATCH[0]="compat-2.6.36-2.6.37.patch"
+PATCH_MATCH[0]="2\.6\.(9|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31|32|33|34|35|36|37)"
 
-PATCH[1]="compat-2.6.31.patch"
-PATCH_MATCH[1]="2\.6\.(9|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31)"
+PATCH[1]="compat-2.6.33-2.6.35.patch"
+PATCH_MATCH[1]="2\.6\.(9|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31|32|33|34|35)"
 
-PATCH[2]="compat-2.6.30.patch"
-PATCH_MATCH[2]="2\.6\.(9|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30)"
+PATCH[2]="compat-2.6.32.patch"
+PATCH_MATCH[2]="2\.6\.(9|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31|32)"
 
-PATCH[3]="compat-2.6.29.patch"
-PATCH_MATCH[3]="2\.6\.(9|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29)"
+PATCH[3]="compat-2.6.31.patch"
+PATCH_MATCH[3]="2\.6\.(9|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31)"
 
-PATCH[4]="compat-2.6.28.patch"
-PATCH_MATCH[4]="2\.6\.(9|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28)"
+PATCH[4]="compat-2.6.30.patch"
+PATCH_MATCH[4]="2\.6\.(9|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30)"
 
-PATCH[5]="compat-2.6.25-2.6.27.patch"
-PATCH_MATCH[5]="2\.6\.(9|14|15|16|17|18|19|20|21|22|23|24|25|26|27)"
+PATCH[5]="compat-2.6.29.patch"
+PATCH_MATCH[5]="2\.6\.(9|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29)"
 
-PATCH[6]="compat-2.6.24.patch"
-PATCH_MATCH[6]="2\.6\.(9|14|15|16|17|18|19|20|21|22|23|24)"
+PATCH[6]="compat-2.6.28.patch"
+PATCH_MATCH[6]="2\.6\.(9|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28)"
 
-PATCH[7]="compat-2.6.23.patch"
-PATCH_MATCH[7]="2\.6\.(9|14|15|16|17|18|19|20|21|22|23)"
+PATCH[7]="compat-2.6.25-2.6.27.patch"
+PATCH_MATCH[7]="2\.6\.(9|14|15|16|17|18|19|20|21|22|23|24|25|26|27)"
 
-PATCH[8]="compat-2.6.22.patch"
-PATCH_MATCH[8]="2\.6\.(9|14|15|16|17|18|19|20|21|22)"
+PATCH[8]="compat-2.6.24.patch"
+PATCH_MATCH[8]="2\.6\.(9|14|15|16|17|18|19|20|21|22|23|24)"
 
-PATCH[9]="compat-2.6.19-2.6.21.patch"
-PATCH_MATCH[9]="2\.6\.(9|14|15|16|17|18|19|20|21)"
+PATCH[9]="compat-2.6.23.patch"
+PATCH_MATCH[9]="2\.6\.(9|14|15|16|17|18|19|20|21|22|23)"
 
-PATCH[10]="compat-2.6.14-2.6.18.patch"
-PATCH_MATCH[10]="2\.6\.(9|14|15|16|17|18)"
+PATCH[10]="compat-2.6.22.patch"
+PATCH_MATCH[10]="2\.6\.(9|14|15|16|17|18|19|20|21|22)"
 
-PATCH[11]="compat-sles10sp2.patch"
-PATCH_MATCH[11]="2\.6\.16\.60-.*"
+PATCH[11]="compat-2.6.19-2.6.21.patch"
+PATCH_MATCH[11]="2\.6\.(9|14|15|16|17|18|19|20|21)"
 
-PATCH[12]="compat-rhel4.patch"
-PATCH_MATCH[12]="2\.6\.9-.*\.(el|plus\.c4)"
+PATCH[12]="compat-2.6.14-2.6.18.patch"
+PATCH_MATCH[12]="2\.6\.(9|14|15|16|17|18)"
+
+PATCH[13]="compat-sles10sp2.patch"
+PATCH_MATCH[13]="2\.6\.16\.60-.*"
+
+PATCH[14]="compat-rhel4.patch"
+PATCH_MATCH[14]="2\.6\.9-.*\.(el|plus\.c4)"
 
diff -ur iscsitarget-1.4.20.2/doc/manpages/ietd.conf.5 iscsitarget-trunk-r453/doc/manpages/ietd.conf.5
--- iscsitarget-1.4.20.2/doc/manpages/ietd.conf.5	2010-03-01 21:42:53.830442000 -0500
+++ iscsitarget-trunk-r453/doc/manpages/ietd.conf.5	2011-03-20 17:48:06.526912000 -0400
@@ -40,7 +40,7 @@
     MaxBurstLength 262144
     FirstBurstLength 65536
     DefaultTime2Wait 2
-    DefaultTime2Retain 20
+    DefaultTime2Retain 0
     MaxOutstandingR2T 8
     NOPInterval 0
     NOPTimeout 0
@@ -279,10 +279,10 @@
 should be set to multiples of PAGE_SIZE. Configuring too large values may lead to problems allocating sufficient memory, which in turn may lead to SCSI commands timing out at the initiator host. The default value is 65536.
 .TP
 .B [DefaultTime2Wait <value>]
-Currently not supported.
+Currently not implemented, but can be used to set how long initiators wait before logging back in after a connection is logged out or dropped.
 .TP
 .B [DefaultTime2Retain <value>]
-Currently not supported.
+Currently we only support 0 which means sessions are not retained after the last connection is logged out or dropped.
 .TP
 .B [MaxOutstandingR2T <value>]
 Optional. Controls the maximum number of data transfers the target may request at once, each of up to
diff -ur iscsitarget-1.4.20.2/etc/ietd.conf iscsitarget-trunk-r453/etc/ietd.conf
--- iscsitarget-1.4.20.2/etc/ietd.conf	2009-11-10 13:35:24.473064000 -0500
+++ iscsitarget-trunk-r453/etc/ietd.conf	2011-03-20 17:48:06.526912000 -0400
@@ -76,10 +76,12 @@
 	#MaxXmitDataSegmentLength 8192		# Max data per PDU to transmit
 	#MaxBurstLength		262144		# Max data per sequence (R2T)
 	#FirstBurstLength	65536		# Max unsolicited data sequence
-	#DefaultTime2Wait	2		# Secs wait for ini to log out
-						# Not used
-	#DefaultTime2Retain	20		# Secs keep cmnds after log out
-						# Not used
+	#DefaultTime2Wait	2		# Secs to wait for ini to logout
+						# also secs for ini to wait
+						# before logging back in
+						# Not implemented, but settable
+	#DefaultTime2Retain	0		# Secs keep session after logout
+						# We only support 0
 	#MaxOutstandingR2T	1		# Max outstanding R2Ts per cmnd
 	#DataPDUInOrder		Yes		# Data in PDUs is ordered
 						# We only support ordered
diff -ur iscsitarget-1.4.20.2/etc/initd/initd iscsitarget-trunk-r453/etc/initd/initd
--- iscsitarget-1.4.20.2/etc/initd/initd	2010-06-29 17:57:27.818218000 -0400
+++ iscsitarget-trunk-r453/etc/initd/initd	2011-03-12 07:14:44.778563000 -0500
@@ -1,4 +1,4 @@
-#!/bin/bash
+#!/bin/sh
 #
 # Start the iSCSI Enterprise Target.
 #
diff -ur iscsitarget-1.4.20.2/etc/initd/initd.debian iscsitarget-trunk-r453/etc/initd/initd.debian
--- iscsitarget-1.4.20.2/etc/initd/initd.debian	2010-06-29 17:57:27.818218000 -0400
+++ iscsitarget-trunk-r453/etc/initd/initd.debian	2011-01-10 17:31:48.461545000 -0500
@@ -7,7 +7,7 @@
 PATH=/sbin:/bin:/usr/sbin:/usr/bin
 DAEMON=/usr/sbin/ietd
 OPTIONS=""
-PIDFILE=/var/run/iscsi_trgt.pid
+PIDFILE=/var/run/ietd.pid
 
 if [ -f /lib/init/vars.sh ]; then
 	. /lib/init/vars.sh
diff -ur iscsitarget-1.4.20.2/etc/initd/initd.gentoo iscsitarget-trunk-r453/etc/initd/initd.gentoo
--- iscsitarget-1.4.20.2/etc/initd/initd.gentoo	2010-06-29 17:57:27.818218000 -0400
+++ iscsitarget-trunk-r453/etc/initd/initd.gentoo	2011-01-10 17:31:48.461545000 -0500
@@ -17,7 +17,7 @@
 	ebegin "Starting iSCSI Target"
 	modprobe -q crc32c
 	modprobe iscsi_trgt
-	start-stop-daemon --start --exec /usr/sbin/ietd --pidfile /var/run/iscsi_trgt.pid -- $OPTIONS
+	start-stop-daemon --start --exec /usr/sbin/ietd --pidfile /var/run/ietd.pid -- $OPTIONS
 	eend $?
 }
 
@@ -25,7 +25,7 @@
 {
 	ebegin "Stopping iSCSI Target"
 	ietadm --op delete
-	start-stop-daemon --stop --exec /usr/sbin/ietd --pidfile /var/run/iscsi_trgt.pid
+	start-stop-daemon --stop --exec /usr/sbin/ietd --pidfile /var/run/ietd.pid
 	rm -f /var/run/iscsi_trgt.pid
 	eend $?
 }
diff -ur iscsitarget-1.4.20.2/include/iet_u.h iscsitarget-trunk-r453/include/iet_u.h
--- iscsitarget-1.4.20.2/include/iet_u.h	2010-07-15 11:15:46.761307000 -0400
+++ iscsitarget-trunk-r453/include/iet_u.h	2010-06-29 18:06:12.385669000 -0400
@@ -1,7 +1,7 @@
 #ifndef _IET_U_H
 #define _IET_U_H
 
-#define IET_VERSION_STRING	"1.4.20.2"
+#define IET_VERSION_STRING	"trunk"
 
 /* The maximum length of 223 bytes in the RFC. */
 #define ISCSI_NAME_LEN	256
diff -ur iscsitarget-1.4.20.2/iscsitarget.spec iscsitarget-trunk-r453/iscsitarget.spec
--- iscsitarget-1.4.20.2/iscsitarget.spec	2010-07-15 11:15:46.761307000 -0400
+++ iscsitarget-trunk-r453/iscsitarget.spec	2011-03-16 17:57:18.706205000 -0400
@@ -3,7 +3,7 @@
 ##
 
 ## IET Release
-%define iet_version 1.4.20.2
+%define iet_version trunk
 
 ## Package Revision
 %define revision 1
@@ -113,7 +113,7 @@
 
 ## Build Requirements
 BuildRequires: kernel >= 2.6
-BuildRequires: gcc, make, patch, binutils, /usr/bin/install, openssl-devel
+BuildRequires: gcc, make, patch, binutils, /usr/bin/install
 %if %is_suse
 BuildRequires: kernel-source = %{kver}
 %else
@@ -408,6 +408,9 @@
 
 
 %changelog
+* Mon Jan 10 2011 Ross Walker <rswwalker at gmail dot com> - 1.4.20.3
+- removed stray RPM build dependency on openssl
+
 * Tue May 11 2010 Ross Walker <rswwalker at gmail dot com> - 1.4.20.2
 - fixed recursive KERNELSRC define problem on SLES
 - updated SVN building to handle tagged builds
diff -ur iscsitarget-1.4.20.2/kernel/block-io.c iscsitarget-trunk-r453/kernel/block-io.c
--- iscsitarget-1.4.20.2/kernel/block-io.c	2010-06-29 18:02:26.570236000 -0400
+++ iscsitarget-trunk-r453/kernel/block-io.c	2011-05-23 15:24:57.968362000 -0400
@@ -56,6 +56,7 @@
 	struct request_queue *bdev_q = bdev_get_queue(bio_data->bdev);
 	struct tio_work *tio_work;
 	struct bio *tio_bio = NULL, *bio = NULL, *biotail = NULL;
+	struct blk_plug plug;
 
 	u32 offset = tio->offset;
 	u32 size = tio->size;
@@ -118,6 +119,8 @@
 		}
 	}
 
+	blk_start_plug(&plug);
+
 	/* Walk the list, submitting bios 1 by 1 */
 	while (tio_bio) {
 		bio = tio_bio;
@@ -127,8 +130,7 @@
 		submit_bio(rw, bio);
 	}
 
-	if (bdev_q && bdev_q->unplug_fn)
-		bdev_q->unplug_fn(bdev_q);
+	blk_finish_plug(&plug);
 
 	wait_for_completion(&tio_work->tio_complete);
 
@@ -155,14 +157,14 @@
 {
 	struct blockio_data *bio_data = volume->private;
 	struct block_device *bdev;
-	int flags = FMODE_READ | (LUReadonly(volume) ? 0 : FMODE_WRITE);
+	int flags = FMODE_EXCL | FMODE_READ | (LUReadonly(volume) ? 0 : FMODE_WRITE);
 	int err = 0;
 
 	bio_data->path = kstrdup(path, GFP_KERNEL);
 	if (!bio_data->path)
 		return -ENOMEM;
 
-	bdev = open_bdev_exclusive(path, flags, THIS_MODULE);
+	bdev = blkdev_get_by_path(path, flags, THIS_MODULE);
 	if (IS_ERR(bdev)) {
 		err = PTR_ERR(bdev);
 		eprintk("Can't open device %s, error %d\n", path, err);
@@ -250,10 +252,10 @@
 blockio_detach(struct iet_volume *volume)
 {
 	struct blockio_data *bio_data = volume->private;
-	int flags = FMODE_READ | (LUReadonly(volume) ? 0 : FMODE_WRITE);
+	int flags = FMODE_EXCL | FMODE_READ | (LUReadonly(volume) ? 0 : FMODE_WRITE);
 
 	if (bio_data->bdev)
-		close_bdev_exclusive(bio_data->bdev, flags);
+		blkdev_put(bio_data->bdev, flags);
 	kfree(bio_data->path);
 
 	kfree(volume->private);
diff -ur iscsitarget-1.4.20.2/kernel/config.c iscsitarget-trunk-r453/kernel/config.c
--- iscsitarget-1.4.20.2/kernel/config.c	2010-03-30 14:08:19.010393000 -0400
+++ iscsitarget-trunk-r453/kernel/config.c	2011-01-12 15:39:36.227592000 -0500
@@ -9,7 +9,7 @@
 #include "iscsi.h"
 #include "iscsi_dbg.h"
 
-static DECLARE_MUTEX(ioctl_sem);
+static DEFINE_MUTEX(ioctl_mutex);
 
 struct proc_entries {
 	const char *name;
@@ -258,7 +258,7 @@
 	long err;
 	u32 id;
 
-	err = down_interruptible(&ioctl_sem);
+	err = mutex_lock_interruptible(&ioctl_mutex);
 	if (err < 0)
 		return err;
 
@@ -339,7 +339,7 @@
 
 	target_unlock(target);
 done:
-	up(&ioctl_sem);
+	mutex_unlock(&ioctl_mutex);
 
 	return err;
 }
@@ -347,9 +347,9 @@
 static int release(struct inode *i __attribute__((unused)),
 		   struct file *f __attribute__((unused)))
 {
-	down(&ioctl_sem);
+	mutex_lock(&ioctl_mutex);
 	target_del_all();
-	up(&ioctl_sem);
+	mutex_unlock(&ioctl_mutex);
 
 	return 0;
 }
diff -ur iscsitarget-1.4.20.2/kernel/conn.c iscsitarget-trunk-r453/kernel/conn.c
--- iscsitarget-1.4.20.2/kernel/conn.c	2010-04-11 11:13:42.626227000 -0400
+++ iscsitarget-trunk-r453/kernel/conn.c	2011-02-18 09:54:13.192266000 -0500
@@ -44,7 +44,7 @@
 		switch (sk->sk_family) {
 		case AF_INET:
 			snprintf(buf, sizeof(buf),
-				 "%u.%u.%u.%u", NIPQUAD(inet_sk(sk)->inet_daddr));
+				 "%pI4", &inet_sk(sk)->inet_daddr);
 			break;
 		case AF_INET6:
 			snprintf(buf, sizeof(buf), "[%pI6]",
@@ -241,8 +241,6 @@
 		conn_close(conn);
 
 	err = iet_conn_alloc(session, info);
-	if (!err && conn)
-		err = -EEXIST;
 
 	return err;
 }
diff -ur iscsitarget-1.4.20.2/kernel/iotype.c iscsitarget-trunk-r453/kernel/iotype.c
--- iscsitarget-1.4.20.2/kernel/iotype.c	2007-08-20 03:23:42.841686000 -0400
+++ iscsitarget-trunk-r453/kernel/iotype.c	2011-05-23 15:24:57.968362000 -0400
@@ -9,7 +9,7 @@
 #include "iscsi_dbg.h"
 
 static LIST_HEAD(iotypes);
-static rwlock_t iotypes_lock = RW_LOCK_UNLOCKED;
+static DEFINE_RWLOCK(iotypes_lock);
 
 static struct iotype *find_iotype(const char *name)
 {
diff -ur iscsitarget-1.4.20.2/kernel/iscsi.c iscsitarget-trunk-r453/kernel/iscsi.c
--- iscsitarget-1.4.20.2/kernel/iscsi.c	2010-04-11 11:53:37.001759000 -0400
+++ iscsitarget-trunk-r453/kernel/iscsi.c	2011-04-14 17:55:25.645527000 -0400
@@ -224,12 +224,12 @@
 	LIST_HEAD(head);
 
 	if (!list_empty(&cmnd->list)) {
-		eprintk("%x %x %x %x %lx %u %u %u %u %u %u %u %d %d\n",
+		eprintk("%x %x %x %x %lx %u %u %u %u %u %u %u %u %d %d\n",
 			cmnd_itt(cmnd), cmnd_ttt(cmnd), cmnd_opcode(cmnd),
 			cmnd_scsicode(cmnd), cmnd->flags, cmnd->r2t_sn,
-			cmnd->r2t_length, cmnd->is_unsolicited_data,
-			cmnd->target_task_tag, cmnd->outstanding_r2t,
-			cmnd->hdigest, cmnd->ddigest,
+			cmnd->r2t_length, cmnd->exp_offset,
+			cmnd->is_unsolicited_data, cmnd->target_task_tag,
+			cmnd->outstanding_r2t, cmnd->hdigest, cmnd->ddigest,
 			list_empty(&cmnd->pdu_list), list_empty(&cmnd->hash_list));
 
 		assert(list_empty(&cmnd->list));
@@ -384,13 +384,29 @@
 void send_data_rsp(struct iscsi_cmnd *req, void (*func)(struct iscsi_cmnd *))
 {
 	struct iscsi_cmnd *rsp;
+	struct iscsi_scsi_rsp_hdr *rsp_hdr;
+	u32 size;
 
 	func(req);
 
-	if (req->status == SAM_STAT_GOOD)
+	assert(req->tio);
+
+	size = min(req->tio->size, cmnd_read_size(req));
+ 
+	if (req->status == SAM_STAT_GOOD && size)
 		do_send_data_rsp(req);
 	else {
 		rsp = create_scsi_rsp(req);
+		rsp_hdr = (struct iscsi_scsi_rsp_hdr *) &rsp->pdu.bhs;
+		if ((size = cmnd_read_size(req)) > req->tio->size) {
+			rsp_hdr->flags |= ISCSI_FLG_RESIDUAL_UNDERFLOW;
+			rsp_hdr->residual_count =
+					cpu_to_be32(size - req->tio->size);
+		} else if (size < req->tio->size) {
+			rsp_hdr->flags |= ISCSI_FLG_RESIDUAL_OVERFLOW;
+			rsp_hdr->residual_count =
+					cpu_to_be32(req->tio->size - size);
+		}
 		iscsi_cmnd_init_write(rsp);
 	}
 }
@@ -510,10 +526,13 @@
 	struct iscsi_conn *conn = cmnd->conn;
 	struct iscsi_session *sess = conn->session;
 
+	sess->max_cmd_sn = sess->exp_cmd_sn + sess->max_queued_cmnds;
+
 	if (set_stat_sn)
 		cmnd->pdu.bhs.sn = cpu_to_be32(conn->stat_sn++);
+
 	cmnd->pdu.bhs.exp_sn = cpu_to_be32(sess->exp_cmd_sn);
-	cmnd->pdu.bhs.max_sn = cpu_to_be32(sess->exp_cmd_sn + sess->max_queued_cmnds);
+	cmnd->pdu.bhs.max_sn = cpu_to_be32(sess->max_cmd_sn);
 }
 
 static void update_stat_sn(struct iscsi_cmnd *cmnd)
@@ -619,8 +638,9 @@
 
 	err = cmnd_insert_hash_ttt(cmnd, ISCSI_RESERVED_TAG);
 	if (!err) {
-		update_stat_sn(cmnd);
 		err = check_cmd_sn(cmnd);
+		if (!err)
+			update_stat_sn(cmnd);
 	} else if (!cmnd_immediate(cmnd))
 		set_cmnd_tmfabort(cmnd);
 
@@ -691,6 +711,9 @@
 	dprintk(D_GENERIC, "%p %u,%u\n", tio, offset, size);
 	offset += tio->offset;
 
+	if (!size)
+		return 0;
+
 	if (!(offset < tio->offset + tio->size) ||
 	    !(offset + size <= tio->offset + tio->size)) {
 		eprintk("%u %u %u %u", offset, size, tio->offset, tio->size);
@@ -793,16 +816,19 @@
 
 static void send_r2t(struct iscsi_cmnd *req)
 {
+	struct iscsi_sess_param *param = &req->conn->session->param;
 	struct iscsi_cmnd *rsp;
 	struct iscsi_r2t_hdr *rsp_hdr;
-	u32 length, offset, burst;
+	u32 offset, burst;
 	LIST_HEAD(send);
 
-	length = req->r2t_length;
-	burst = req->conn->session->param.max_burst_length;
-	offset = be32_to_cpu(cmnd_hdr(req)->data_length) - length;
+	if (req->outstanding_r2t >= param->max_outstanding_r2t)
+		return;
+
+	burst = param->max_burst_length;
+	offset = cmnd_write_size(req) - req->r2t_length;
 
-	do {
+	while (req->r2t_length) {
 		rsp = iscsi_cmnd_create_rsp_cmnd(req, 0);
 		rsp->pdu.bhs.ttt = req->target_task_tag;
 
@@ -813,13 +839,13 @@
 		rsp_hdr->itt = cmnd_hdr(req)->itt;
 		rsp_hdr->r2t_sn = cpu_to_be32(req->r2t_sn++);
 		rsp_hdr->buffer_offset = cpu_to_be32(offset);
-		if (length > burst) {
+		if (req->r2t_length > burst) {
 			rsp_hdr->data_length = cpu_to_be32(burst);
-			length -= burst;
+			req->r2t_length -= burst;
 			offset += burst;
 		} else {
-			rsp_hdr->data_length = cpu_to_be32(length);
-			length = 0;
+			rsp_hdr->data_length = cpu_to_be32(req->r2t_length);
+			req->r2t_length = 0;
 		}
 
 		dprintk(D_WRITE, "%x %u %u %u %u\n", cmnd_itt(req),
@@ -829,17 +855,17 @@
 
 		list_add_tail(&rsp->list, &send);
 
-		if (++req->outstanding_r2t >= req->conn->session->param.max_outstanding_r2t)
+		if (++req->outstanding_r2t >= param->max_outstanding_r2t)
 			break;
+	}
 
-	} while (length);
-
-	iscsi_cmnds_init_write(&send);
+	if (!list_empty(&send))
+		iscsi_cmnds_init_write(&send);
 }
 
 static void scsi_cmnd_exec(struct iscsi_cmnd *cmnd)
 {
-	assert(!cmnd->r2t_length);
+	assert(!(cmnd->r2t_length || cmnd->outstanding_r2t));
 
 	if (cmnd->lun) {
 		iscsi_scsi_queuecmnd(cmnd);
@@ -876,10 +902,10 @@
 	if (cmnd_itt(cmnd) == cpu_to_be32(ISCSI_RESERVED_TAG)) {
 		if (!cmnd_immediate(cmnd))
 			eprintk("%s\n", "initiator bug!");
-		update_stat_sn(cmnd);
 		err = check_cmd_sn(cmnd);
 		if (err)
 			goto out;
+		update_stat_sn(cmnd);
 	} else if ((err = cmnd_insert_hash(cmnd)) < 0) {
 		eprintk("ignore this request %x\n", cmnd_itt(cmnd));
 		goto out;
@@ -1008,7 +1034,8 @@
 		loff_t offset;
 		u32 length;
 
-		req->r2t_length = be32_to_cpu(req_hdr->data_length) - req->pdu.datasize;
+		req->exp_offset = req->pdu.datasize;
+		req->r2t_length = cmnd_write_size(req) - req->pdu.datasize;
 		req->is_unsolicited_data = !(req_hdr->flags & ISCSI_CMD_FINAL);
 		req->target_task_tag = get_next_ttt(conn->session);
 
@@ -1054,6 +1081,7 @@
 
 static void data_out_start(struct iscsi_conn *conn, struct iscsi_cmnd *cmnd)
 {
+	struct iscsi_sess_param *param = &conn->session->param;
 	struct iscsi_data_out_hdr *req = (struct iscsi_data_out_hdr *)&cmnd->pdu.bhs;
 	struct iscsi_cmnd *scsi_cmnd = NULL;
 	u32 offset = be32_to_cpu(req->buffer_offset);
@@ -1067,24 +1095,28 @@
 		goto skip_data;
 	}
 
-	if (scsi_cmnd->r2t_length < cmnd->pdu.datasize) {
-		eprintk("invalid data len %x %u %u\n",
-			cmnd_itt(scsi_cmnd), cmnd->pdu.datasize, scsi_cmnd->r2t_length);
+	if (param->data_pdu_inorder && offset != scsi_cmnd->exp_offset) {
+		eprintk("invalid data offset %x %u %u\n",
+			cmnd_itt(scsi_cmnd), offset, cmnd->exp_offset);
 		goto skip_data;
 	}
 
-	if (scsi_cmnd->r2t_length + offset != cmnd_write_size(scsi_cmnd)) {
-		eprintk("%x %u %u %u\n", cmnd_itt(scsi_cmnd), scsi_cmnd->r2t_length,
-			offset,	cmnd_write_size(scsi_cmnd));
+	if (offset + cmnd->pdu.datasize > cmnd_write_size(scsi_cmnd)) {
+		eprintk("invalid data length %x %u %u\n",
+			cmnd_itt(scsi_cmnd),(offset + cmnd->pdu.datasize),
+			cmnd_write_size(scsi_cmnd));
 		goto skip_data;
 	}
 
-	scsi_cmnd->r2t_length -= cmnd->pdu.datasize;
-
-	if (req->ttt == cpu_to_be32(ISCSI_RESERVED_TAG)) {
-		/* unsolicited burst data */
-		if (scsi_cmnd->pdu.bhs.flags & ISCSI_FLG_FINAL) {
-			eprintk("unexpected data from %x %x\n",
+	if (scsi_cmnd->is_unsolicited_data) {
+		if (offset + cmnd->pdu.datasize > param->first_burst_length) {
+			eprintk("unsolicited data > first burst length %x %x\n",
+				cmnd_itt(cmnd), cmnd_ttt(cmnd));
+			goto skip_data;
+		}
+	} else {
+		if (req->ttt == cpu_to_be32(ISCSI_RESERVED_TAG)) {
+			eprintk("unexpected unsolicited data %x %x\n",
 				cmnd_itt(cmnd), cmnd_ttt(cmnd));
 			goto skip_data;
 		}
@@ -1095,6 +1127,12 @@
 
 	if (cmnd_recv_pdu(conn, scsi_cmnd->tio, offset, cmnd->pdu.datasize) < 0)
 		goto skip_data;
+
+	if (scsi_cmnd->is_unsolicited_data)
+		scsi_cmnd->r2t_length -= cmnd->pdu.datasize;
+
+	scsi_cmnd->exp_offset += cmnd->pdu.datasize;
+
 	return;
 
 skip_data:
@@ -1116,7 +1154,8 @@
 	assert(scsi_cmnd);
 
 	if (conn->read_overflow) {
-		eprintk("%x %u\n", cmnd_itt(cmnd), conn->read_overflow);
+		eprintk("connection read overflow %x %u\n",
+			cmnd_itt(cmnd), conn->read_overflow);
 		assert(scsi_cmnd->tio);
 		offset = be32_to_cpu(req->buffer_offset);
 		offset += cmnd->pdu.datasize - conn->read_overflow;
@@ -1125,28 +1164,18 @@
 		return;
 	}
 
-	if (req->ttt == cpu_to_be32(ISCSI_RESERVED_TAG)) {
-		if (req->flags & ISCSI_FLG_FINAL) {
+	if (req->flags & ISCSI_FLG_FINAL) {
+		if (req->ttt == cpu_to_be32(ISCSI_RESERVED_TAG))
 			scsi_cmnd->is_unsolicited_data = 0;
-			iscsi_session_push_cmnd(scsi_cmnd);
-		}
-	} else {
-		/* TODO : proper error handling */
-		if (!(req->flags & ISCSI_FLG_FINAL) && scsi_cmnd->r2t_length == 0)
-			eprintk("initiator error %x\n", cmnd_itt(scsi_cmnd));
-
-		if (!(req->flags & ISCSI_FLG_FINAL))
-			goto out;
-
-		scsi_cmnd->outstanding_r2t--;
+		else
+			scsi_cmnd->outstanding_r2t--;
 
-		if (scsi_cmnd->r2t_length == 0)
+		if (scsi_cmnd->outstanding_r2t == 0)
 			assert(list_empty(&scsi_cmnd->pdu_list));
 
 		iscsi_session_push_cmnd(scsi_cmnd);
 	}
 
-out:
 	iscsi_cmnd_remove(cmnd);
 	return;
 }
@@ -1500,6 +1529,8 @@
 	struct iscsi_logout_req_hdr *req_hdr;
 	struct iscsi_cmnd *rsp;
 	struct iscsi_logout_rsp_hdr *rsp_hdr;
+	struct iscsi_conn *conn;
+	u8 reason;
 
 	req_hdr = (struct iscsi_logout_req_hdr *)&req->pdu.bhs;
 	rsp = iscsi_cmnd_create_rsp_cmnd(req, 1);
@@ -1507,7 +1538,30 @@
 	rsp_hdr->opcode = ISCSI_OP_LOGOUT_RSP;
 	rsp_hdr->flags = ISCSI_FLG_FINAL;
 	rsp_hdr->itt = req_hdr->itt;
-	set_cmnd_close(rsp);
+
+	reason = req_hdr->flags & ISCSI_FUNCTION_MASK;
+
+	if (reason == ISCSI_LOGOUT_SESSION)
+		set_cmnd_closeit(rsp);
+	else if (reason == ISCSI_LOGOUT_CONNECTION) {
+		if (req_hdr->cid != req->conn->cid) {
+			conn = conn_lookup(req->conn->session, req_hdr->cid);
+
+			if (!conn)
+				rsp_hdr->response = 1;
+			else if (test_bit(CONN_ACTIVE, &conn->state))
+				rsp_hdr->response = 3;
+			else {
+				/* end time2wait timer for conn */
+			}
+		} else
+			set_cmnd_close(rsp);
+	} else if (reason == ISCSI_LOGOUT_CONNECTION_RECOVER)
+		rsp_hdr->response = 2;
+	else
+		/* protocol error */
+		conn_close(req->conn);
+
 	iscsi_cmnd_init_write(rsp);
 }
 
@@ -1701,6 +1755,7 @@
 
 void cmnd_tx_end(struct iscsi_cmnd *cmnd)
 {
+	struct iscsi_session *session = cmnd->conn->session;
 	struct iscsi_conn *conn = cmnd->conn;
 
 	dprintk(D_GENERIC, "%p:%x\n", cmnd, cmnd_opcode(cmnd));
@@ -1725,6 +1780,9 @@
 
 	if (cmnd_close(cmnd))
 		conn_close(conn);
+	else if (cmnd_closeit(cmnd))
+		list_for_each_entry(conn, &session->conn_list, list)
+			conn_close(conn);
 
 	list_del_init(&cmnd->list);
 	set_cork(cmnd->conn->sock, 0);
@@ -1751,6 +1809,9 @@
 		return;
 	}
 
+	if (cmnd->outstanding_r2t)
+		return;
+
 	dprintk(D_GENERIC, "%p:%x %u,%u\n",
 		cmnd, cmnd_opcode(cmnd), cmnd->pdu.bhs.sn, session->exp_cmd_sn);
 
@@ -1798,11 +1859,8 @@
 	if (cmnd->pdu.datasize > param->max_recv_data_length) {
 		eprintk("data too long %x %u %u\n", cmnd_itt(cmnd),
 			cmnd->pdu.datasize, param->max_recv_data_length);
-
-		if (get_pgcnt(cmnd->pdu.datasize, 0) > ISCSI_CONN_IOV_MAX) {
-			conn_close(conn);
-			return -EINVAL;
-		}
+		conn_close(conn);
+		return -EINVAL;
 	}
 
 	return 0;
diff -ur iscsitarget-1.4.20.2/kernel/iscsi.h iscsitarget-trunk-r453/kernel/iscsi.h
--- iscsitarget-1.4.20.2/kernel/iscsi.h	2010-06-29 18:02:26.570236000 -0400
+++ iscsitarget-trunk-r453/kernel/iscsi.h	2011-04-14 17:55:25.645527000 -0400
@@ -130,7 +130,7 @@
 	/* Points either to own list or global pool */
 	struct worker_thread_info * wthread_info;
 
-	struct semaphore target_sem;
+	struct mutex target_mutex;
 };
 
 struct iscsi_queue {
@@ -296,6 +296,7 @@
 
 	u32 r2t_sn;
 	u32 r2t_length;
+	u32 exp_offset;
 	u32 is_unsolicited_data;
 	u32 target_task_tag;
 	u32 outstanding_r2t;
@@ -477,6 +478,7 @@
 	CMND_final,
 	CMND_waitio,
 	CMND_close,
+	CMND_closeit,
 	CMND_lunit,
 	CMND_pending,
 	CMND_tmfabort,
@@ -499,6 +501,9 @@
 #define set_cmnd_close(cmnd)	set_bit(CMND_close, &(cmnd)->flags)
 #define cmnd_close(cmnd)	test_bit(CMND_close, &(cmnd)->flags)
 
+#define set_cmnd_closeit(cmnd)	set_bit(CMND_closeit, &(cmnd)->flags)
+#define cmnd_closeit(cmnd)	test_bit(CMND_closeit, &(cmnd)->flags)
+
 #define set_cmnd_lunit(cmnd)	set_bit(CMND_lunit, &(cmnd)->flags)
 #define cmnd_lunit(cmnd)	test_bit(CMND_lunit, &(cmnd)->flags)
 
diff -ur iscsitarget-1.4.20.2/kernel/iscsi_hdr.h iscsitarget-trunk-r453/kernel/iscsi_hdr.h
--- iscsitarget-1.4.20.2/kernel/iscsi_hdr.h	2009-10-08 14:29:17.953238000 -0400
+++ iscsitarget-trunk-r453/kernel/iscsi_hdr.h	2011-04-14 17:55:25.645527000 -0400
@@ -428,6 +428,10 @@
 	u32 rsvd5;
 } __packed;
 
+#define ISCSI_LOGOUT_SESSION			0
+#define ISCSI_LOGOUT_CONNECTION			1
+#define ISCSI_LOGOUT_CONNECTION_RECOVER		2
+
 struct iscsi_snack_req_hdr {
 	u8  opcode;
 	u8  flags;
diff -ur iscsitarget-1.4.20.2/kernel/nthread.c iscsitarget-trunk-r453/kernel/nthread.c
--- iscsitarget-1.4.20.2/kernel/nthread.c	2010-03-30 14:03:02.028277000 -0400
+++ iscsitarget-trunk-r453/kernel/nthread.c	2011-03-31 11:57:36.704467000 -0400
@@ -242,7 +242,7 @@
 	case RX_CHECK_HDIGEST:
 		rx_hdigest(conn, RX_INIT_DATA);
 		if (conn->read_state != RX_INIT_DATA)
-			break;
+			return -EIO;
 	case RX_INIT_DATA:
 		cmnd_rx_start(cmnd);
 		conn->read_state = cmnd->pdu.datasize ? RX_DATA : RX_END;
@@ -261,6 +261,8 @@
 			break;
 	case RX_CHECK_DDIGEST:
 		rx_ddigest(conn, RX_END);
+		if (conn->read_state != RX_END)
+			return -EIO;
 		break;
 	default:
 		eprintk("%d %d %x\n", res, conn->read_state, cmnd_opcode(cmnd));
diff -ur iscsitarget-1.4.20.2/kernel/param.c iscsitarget-trunk-r453/kernel/param.c
--- iscsitarget-1.4.20.2/kernel/param.c	2010-04-08 16:45:28.508001000 -0400
+++ iscsitarget-trunk-r453/kernel/param.c	2011-03-20 17:48:06.526912000 -0400
@@ -51,6 +51,7 @@
 	CHECK_PARAM(info, iparam, error_recovery_level, 0, 0);
 	CHECK_PARAM(info, iparam, data_pdu_inorder, 1, 1);
 	CHECK_PARAM(info, iparam, data_sequence_inorder, 1, 1);
+	CHECK_PARAM(info, iparam, default_retain_time, 0, 0);
 
 	digest_alg_available(&iparam[key_header_digest]);
 	digest_alg_available(&iparam[key_data_digest]);
diff -ur iscsitarget-1.4.20.2/kernel/target.c iscsitarget-trunk-r453/kernel/target.c
--- iscsitarget-1.4.20.2/kernel/target.c	2010-04-11 12:06:14.107325000 -0400
+++ iscsitarget-trunk-r453/kernel/target.c	2011-04-14 17:51:47.950291000 -0400
@@ -4,6 +4,8 @@
  * Released under the terms of the GNU GPL v2.0.
  */
 
+#include <linux/mutex.h>
+
 #include "iscsi.h"
 #include "digest.h"
 #include "iscsi_dbg.h"
@@ -11,7 +13,7 @@
 #define	MAX_NR_TARGETS	(1UL << 30)
 
 static LIST_HEAD(target_list);
-static DECLARE_MUTEX(target_list_sem);
+static DEFINE_MUTEX(target_list_mutex);
 static u32 next_target_id;
 static u32 nr_targets;
 
@@ -24,7 +26,7 @@
 	.max_burst_length = 262144,
 	.first_burst_length = 65536,
 	.default_wait_time = 2,
-	.default_retain_time = 20,
+	.default_retain_time = 0,
 	.max_outstanding_r2t = 1,
 	.data_pdu_inorder = 1,
 	.data_sequence_inorder = 1,
@@ -48,16 +50,16 @@
 	int err = 0;
 
 	if (interruptible)
-		err = down_interruptible(&target->target_sem);
+		err = mutex_lock_interruptible(&target->target_mutex);
 	else
-		down(&target->target_sem);
+		mutex_lock(&target->target_mutex);
 
 	return err;
 }
 
 inline void target_unlock(struct iscsi_target *target)
 {
-	up(&target->target_sem);
+	mutex_unlock(&target->target_mutex);
 }
 
 static struct iscsi_target *__target_lookup_by_id(u32 id)
@@ -86,9 +88,9 @@
 {
 	struct iscsi_target *target;
 
-	down(&target_list_sem);
+	mutex_lock(&target_list_mutex);
 	target = __target_lookup_by_id(id);
-	up(&target_list_sem);
+	mutex_unlock(&target_list_mutex);
 
 	return target;
 }
@@ -157,7 +159,7 @@
 
 	strncpy(target->name, name, sizeof(target->name) - 1);
 
-	init_MUTEX(&target->target_sem);
+	mutex_init(&target->target_mutex);
 	spin_lock_init(&target->session_list_lock);
 
 	INIT_LIST_HEAD(&target->session_list);
@@ -195,7 +197,7 @@
 	u32 tid = info->tid;
 	int err;
 
-	err = down_interruptible(&target_list_sem);
+	err = mutex_lock_interruptible(&target_list_mutex);
 	if (err < 0)
 		return err;
 
@@ -204,7 +206,7 @@
 		goto out;
 	}
 
-	if (__target_lookup_by_name(info->name) || 
+	if (__target_lookup_by_name(info->name) ||
 			(tid && __target_lookup_by_id(tid))) {
 		err = -EEXIST;
 		goto out;
@@ -223,7 +225,7 @@
 	if (!err)
 		nr_targets++;
 out:
-	up(&target_list_sem);
+	mutex_unlock(&target_list_mutex);
 
 	return err;
 }
@@ -232,8 +234,6 @@
 {
 	dprintk(D_SETUP, "%u\n", target->tid);
 
-	target_thread_stop(target);
-
 	while (!list_empty(&target->volumes)) {
 		struct iet_volume *volume;
 		volume = list_entry(target->volumes.next, struct iet_volume, list);
@@ -241,6 +241,8 @@
 		iscsi_volume_destroy(volume);
 	}
 
+	target_thread_stop(target);
+
 	if (!worker_thread_pool)
 		kfree(target->wthread_info);
 	kfree(target);
@@ -248,7 +250,7 @@
 	module_put(THIS_MODULE);
 }
 
-/* @locking: target_list_sem must be locked */
+/* @locking: target_list_mutex must be locked */
 static int __target_del(struct iscsi_target *target)
 {
 	int err;
@@ -283,7 +285,7 @@
 	struct iscsi_target *target;
 	int err;
 
-	err = down_interruptible(&target_list_sem);
+	err = mutex_lock_interruptible(&target_list_mutex);
 	if (err < 0)
 		return err;
 
@@ -295,7 +297,7 @@
 
 	err = __target_del(target);
 out:
-	up(&target_list_sem);
+	mutex_unlock(&target_list_mutex);
 
 	return err;
 }
@@ -305,7 +307,7 @@
 	struct iscsi_target *target, *tmp;
 	int err;
 
-	down(&target_list_sem);
+	mutex_lock(&target_list_mutex);
 
 	if (!list_empty(&target_list))
 		iprintk("Removing all connections, sessions and targets\n");
@@ -319,7 +321,7 @@
 
 	next_target_id = 0;
 
-	up(&target_list_sem);
+	mutex_unlock(&target_list_mutex);
 }
 
 static void *iet_seq_start(struct seq_file *m, loff_t *pos)
@@ -327,7 +329,7 @@
 	int err;
 
 	/* are you sure this is to be interruptible? */
-	err = down_interruptible(&target_list_sem);
+	err = mutex_lock_interruptible(&target_list_mutex);
 	if (err < 0)
 		return ERR_PTR(err);
 
@@ -341,7 +343,7 @@
 
 static void iet_seq_stop(struct seq_file *m, void *v)
 {
-	up(&target_list_sem);
+	mutex_unlock(&target_list_mutex);
 }
 
 static int iet_seq_show(struct seq_file *m, void *p)
diff -ur iscsitarget-1.4.20.2/kernel/target_disk.c iscsitarget-trunk-r453/kernel/target_disk.c
--- iscsitarget-1.4.20.2/kernel/target_disk.c	2010-04-25 07:09:59.637115000 -0400
+++ iscsitarget-trunk-r453/kernel/target_disk.c	2011-01-28 14:56:38.867690000 -0500
@@ -247,7 +247,7 @@
 			data[7] = len;
 			if (cmnd->lun) { /* We need this ? */
 				memset(data + 8, 0x00, 8);
-				memcpy(data + 8, VENDOR_ID, 
+				memcpy(data + 8, VENDOR_ID,
 					min_t(size_t, strlen(VENDOR_ID), 8));
 				memcpy(data + 16, cmnd->lun->scsi_id,
 								SCSI_ID_LEN);
@@ -477,11 +477,17 @@
 			break;
 		default:
 			ua = ua_get_first(cmnd->conn->session, cmnd->lun->lun);
-			iscsi_cmnd_set_sense(cmnd, UNIT_ATTENTION, ua->asc,
-					     ua->ascq);
-			ua_free(ua);
-			send_scsi_rsp(cmnd, build_generic_response);
-			return 1;
+			/*
+			 * potential race: another wthread could've reported it
+			 * in the meantime
+			 */
+			if (ua) {
+				iscsi_cmnd_set_sense(cmnd, UNIT_ATTENTION, ua->asc,
+						     ua->ascq);
+				ua_free(ua);
+				send_scsi_rsp(cmnd, build_generic_response);
+				return 1;
+			}
 		}
 	}
 	return 0;
diff -ur iscsitarget-1.4.20.2/kernel/tio.c iscsitarget-trunk-r453/kernel/tio.c
--- iscsitarget-1.4.20.2/kernel/tio.c	2007-09-20 19:26:20.431824000 -0400
+++ iscsitarget-trunk-r453/kernel/tio.c	2011-03-31 12:52:38.471017000 -0400
@@ -91,6 +91,8 @@
 {
 	struct iotype *iot = lu->iotype;
 	assert(iot);
+	if (!tio->size)
+		return 0;
 	return iot->make_request ? iot->make_request(lu, tio, READ) : 0;
 }
 
@@ -98,6 +100,8 @@
 {
 	struct iotype *iot = lu->iotype;
 	assert(iot);
+	if (!tio->size)
+		return 0;
 	return iot->make_request ? iot->make_request(lu, tio, WRITE) : 0;
 }
 
diff -ur iscsitarget-1.4.20.2/kernel/volume.c iscsitarget-trunk-r453/kernel/volume.c
--- iscsitarget-1.4.20.2/kernel/volume.c	2010-06-29 18:02:26.570236000 -0400
+++ iscsitarget-trunk-r453/kernel/volume.c	2011-01-19 10:41:56.774297000 -0500
@@ -6,6 +6,7 @@
 
 #include <linux/types.h>
 #include <linux/parser.h>
+#include <linux/blkdev.h>
 
 #include "iscsi.h"
 #include "iscsi_dbg.h"
@@ -87,7 +88,7 @@
 	hash.tfm = crypto_alloc_hash("md5", 0, CRYPTO_ALG_ASYNC);
 	hash.flags = 0;
 
-	if (hash.tfm) {
+	if (!IS_ERR(hash.tfm)) {
 		struct scatterlist sg[2];
 		unsigned int nbytes = 0;
 
@@ -111,8 +112,7 @@
 						sizeof(volume->target->tid));
 		memcpy(volume->scsi_id + sizeof(volume->target->tid),
 					&volume->lun, sizeof(volume->lun));
-	}	
-
+	}
 }
 
 static int parse_volume_params(struct iet_volume *volume, char *params)
@@ -120,11 +120,13 @@
 	int err = 0;
 	unsigned blk_sz;
 	substring_t args[MAX_OPT_ARGS];
-	char *p, *argp = NULL, *buf = (char *) get_zeroed_page(GFP_USER);
+	char *p, *argp = NULL, *bp, *buf = (char *) get_zeroed_page(GFP_USER);
 
 	if (!buf)
 		return -ENOMEM;
 
+	bp = buf;
+
 	strncpy(buf, params, PAGE_CACHE_SIZE);
 
 	while ((p = strsep(&buf, ",")) != NULL) {
@@ -203,7 +205,7 @@
 		err = -EINVAL;
 	}
 
-	free_page((unsigned long) buf);
+	free_page((unsigned long) bp);
 
 	return err;
 }
diff -ur iscsitarget-1.4.20.2/kernel/wthread.c iscsitarget-trunk-r453/kernel/wthread.c
--- iscsitarget-1.4.20.2/kernel/wthread.c	2010-04-11 11:34:14.547091000 -0400
+++ iscsitarget-trunk-r453/kernel/wthread.c	2011-04-14 17:51:47.950291000 -0400
@@ -67,14 +67,11 @@
 	struct iscsi_conn *conn;
 	DECLARE_WAITQUEUE(wait, current);
 
-	get_io_context(GFP_KERNEL, -1);
+	if (current->io_context)
+		put_io_context(current->io_context);
 
-	if (!current->io_context)
-		eprintk("%s\n", "Failed to get IO context");
-	else if (info->wthread_ioc)
-		copy_io_context(&current->io_context, &info->wthread_ioc);
-	else
-		info->wthread_ioc = current->io_context;
+	if (!(current->io_context = ioc_task_link(info->wthread_ioc)))
+		info->wthread_ioc = get_io_context(GFP_KERNEL, -1);
 
 	add_wait_queue(&info->wthread_sleep, &wait);
 
@@ -100,16 +97,6 @@
 
 	remove_wait_queue(&info->wthread_sleep, &wait);
 
-	if (current->io_context) {
-		struct io_context *ioc = current->io_context;
-
-		task_lock(current);
-		current->io_context = NULL;
-		task_unlock(current);
-
-		put_io_context(ioc);
-	}
-
 	return 0;
 }
 
diff -ur iscsitarget-1.4.20.2/patches/compat-2.6.14-2.6.18.patch iscsitarget-trunk-r453/patches/compat-2.6.14-2.6.18.patch
--- iscsitarget-1.4.20.2/patches/compat-2.6.14-2.6.18.patch	2010-06-29 18:02:26.570236000 -0400
+++ iscsitarget-trunk-r453/patches/compat-2.6.14-2.6.18.patch	2011-04-14 17:51:47.950291000 -0400
@@ -2,7 +2,7 @@
 ===================================================================
 --- 1/kernel/iscsi.h	(revision 105)
 +++ 2/kernel/iscsi.h	(working copy)
-@@ -261,8 +261,8 @@ struct iscsi_conn {
+@@ -260,8 +260,8 @@ struct iscsi_conn {
  	u32 write_offset;
  	int write_state;
  
@@ -199,17 +199,6 @@
  
  struct tio *tio_alloc(int count)
  {
---- context/kernel/wthread.c	2010-01-25 11:27:57.000000000 -0500
-+++ context/kernel/wthread.c.18	2010-01-25 11:25:43.000000000 -0500
-@@ -67,7 +67,7 @@
- 	struct iscsi_conn *conn;
- 	DECLARE_WAITQUEUE(wait, current);
- 
--	get_io_context(GFP_KERNEL, -1);
-+	get_io_context(GFP_KERNEL);
- 
- 	if (!current->io_context)
- 		eprintk("%s\n", "Failed to get IO context");
 --- param/kernel/volume.c	2010-04-08 18:05:38.000000000 -0400
 +++ param/kernel/volume.c.18	2010-04-08 18:05:38.000000000 -0400
 @@ -84,28 +84,26 @@ static int set_scsisn(struct iet_volume 
@@ -223,7 +212,7 @@
 -	hash.flags = 0;
 +	tfm = crypto_alloc_tfm("md5", 0);
  
--	if (hash.tfm) {
+-	if (!IS_ERR(hash.tfm)) {
 +	if (tfm) {
  		struct scatterlist sg[2];
 -		unsigned int nbytes = 0;
@@ -250,3 +239,14 @@
  	} else {
  		/* If no MD5 available set ID to TID and LUN */
  		memcpy(volume->scsi_id, &volume->target->tid,
+--- ioc/kernel/wthread.c	2011-04-12 19:50:49.000000000 -0400
++++ ioc/kernel/wthread.c	2011-04-12 19:51:29.000000000 -0400
+@@ -68,7 +68,7 @@ static int worker_thread(void *arg)
+ 	DECLARE_WAITQUEUE(wait, current);
+ 
+ 	if (!current->io_context)
+-		get_io_context(GFP_KERNEL, -1);
++		get_io_context(GFP_KERNEL);
+ 
+ 	add_wait_queue(&info->wthread_sleep, &wait);
+ 
diff -ur iscsitarget-1.4.20.2/patches/compat-2.6.19-2.6.21.patch iscsitarget-trunk-r453/patches/compat-2.6.19-2.6.21.patch
--- iscsitarget-1.4.20.2/patches/compat-2.6.19-2.6.21.patch	2010-04-13 13:13:44.295587000 -0400
+++ iscsitarget-trunk-r453/patches/compat-2.6.19-2.6.21.patch	2011-04-14 17:51:47.950291000 -0400
@@ -16,7 +16,7 @@
 ===================================================================
 --- 1/kernel/iscsi.c	(working copy)
 +++ 2/kernel/iscsi.c	(revision 137)
-@@ -1925,7 +1925,8 @@ static int iscsi_init(void)
+@@ -1942,7 +1942,8 @@ static int iscsi_init(void)
  	if ((err = event_init()) < 0)
  		goto err;
 
@@ -30,7 +30,7 @@
 ===================================================================
 --- 1/kernel/tio.c	(working copy)
 +++ 2/kernel/tio.c	(revision 137)
-@@ -110,7 +110,8 @@ int tio_sync(struct iet_volume *lu, stru
+@@ -114,7 +114,8 @@ int tio_sync(struct iet_volume *lu, stru
 
  int tio_init(void)
  {
diff -ur iscsitarget-1.4.20.2/patches/compat-2.6.22.patch iscsitarget-trunk-r453/patches/compat-2.6.22.patch
--- iscsitarget-1.4.20.2/patches/compat-2.6.22.patch	2010-04-08 18:25:37.621131000 -0400
+++ iscsitarget-trunk-r453/patches/compat-2.6.22.patch	2011-03-20 12:56:33.222997000 -0400
@@ -53,7 +53,7 @@
 ===================================================================
 --- a/kernel/target.c	(revision 205)
 +++ b/kernel/target.c	(working copy)
-@@ -7,6 +7,7 @@
+@@ -9,6 +9,7 @@
  #include "iscsi.h"
  #include "digest.h"
  #include "iscsi_dbg.h"
diff -ur iscsitarget-1.4.20.2/patches/compat-2.6.24.patch iscsitarget-trunk-r453/patches/compat-2.6.24.patch
--- iscsitarget-1.4.20.2/patches/compat-2.6.24.patch	2009-01-24 08:08:41.743780000 -0500
+++ iscsitarget-trunk-r453/patches/compat-2.6.24.patch	2011-04-14 17:51:47.950291000 -0400
@@ -10,3 +10,38 @@
 +	if (nl)
 +		sock_release(nl->sk_socket);
  }
+--- ioc/kernel/iscsi.h	2011-04-12 17:31:46.000000000 -0400
++++ ioc/kernel/iscsi.h	2011-04-12 17:46:06.000000000 -0400
+@@ -94,8 +94,6 @@ struct worker_thread_info {
+ 	struct list_head work_queue;
+ 
+ 	wait_queue_head_t wthread_sleep;
+-
+-	struct io_context *wthread_ioc;
+ };
+ 
+ struct iscsi_cmnd;
+--- ioc/kernel/wthread.c	2011-04-12 19:49:26.000000000 -0400
++++ ioc/kernel/wthread.c	2011-04-12 19:50:49.000000000 -0400
+@@ -67,11 +67,8 @@ static int worker_thread(void *arg)
+ 	struct iscsi_conn *conn;
+ 	DECLARE_WAITQUEUE(wait, current);
+ 
+-	if (current->io_context)
+-		put_io_context(current->io_context);
+-
+-	if (!(current->io_context = ioc_task_link(info->wthread_ioc)))
+-		info->wthread_ioc = get_io_context(GFP_KERNEL, -1);
++	if (!current->io_context)
++		get_io_context(GFP_KERNEL, -1);
+ 
+ 	add_wait_queue(&info->wthread_sleep, &wait);
+ 
+@@ -147,7 +144,6 @@ int wthread_init(struct worker_thread_in
+ 	spin_lock_init(&info->wthread_lock);
+ 
+ 	info->nr_running_wthreads = 0;
+-	info->wthread_ioc = NULL;
+ 
+ 	INIT_LIST_HEAD(&info->work_queue);
+ 	INIT_LIST_HEAD(&info->wthread_list);
diff -ur iscsitarget-1.4.20.2/patches/compat-2.6.30.patch iscsitarget-trunk-r453/patches/compat-2.6.30.patch
--- iscsitarget-1.4.20.2/patches/compat-2.6.30.patch	2010-04-08 18:25:37.621131000 -0400
+++ iscsitarget-trunk-r453/patches/compat-2.6.30.patch	2011-04-14 17:51:47.950291000 -0400
@@ -7,5 +7,5 @@
 -		unsigned bsz = bdev_logical_block_size(bio_data->bdev);
 +		unsigned bsz = bdev_hardsect_size(bio_data->bdev);
  		if (!volume->blk_shift)
- 			volume->blk_shift = ilog2(bsz);
- 		else if (volume->blk_shift < ilog2(bsz)) {
+ 			volume->blk_shift = blksize_bits(bsz);
+ 		else if (volume->blk_shift < blksize_bits(bsz)) {
Only in iscsitarget-trunk-r453/patches: compat-2.6.33-2.6.35.patch
Only in iscsitarget-trunk-r453/patches: compat-2.6.36-2.6.37.patch
Only in iscsitarget-trunk-r453/patches: compat-2.6.38.patch
diff -ur iscsitarget-1.4.20.2/usr/Makefile iscsitarget-trunk-r453/usr/Makefile
--- iscsitarget-1.4.20.2/usr/Makefile	2010-04-13 10:53:30.472614000 -0400
+++ iscsitarget-trunk-r453/usr/Makefile	2011-03-12 07:13:54.456445000 -0500
@@ -1,4 +1,4 @@
-CFLAGS += -O2 -fno-inline -Wall -Wstrict-prototypes -g -I../include
+CFLAGS += -O2 -fno-inline -Wall -Wstrict-prototypes -I../include
 CFLAGS += -D_GNU_SOURCE # required for glibc >= 2.8
 PROGRAMS = ietd ietadm
 LIBS =
@@ -7,10 +7,10 @@
 
 ietd: ietd.o iscsid.o conn.o session.o target.o message.o ctldev.o log.o chap.o event.o param.o plain.o isns.o md5.o sha1.o
 
-	$(CC) $^ -o $@ $(LIBS)
+	$(CC) $(LDFLAGS) $^ -o $@ $(LIBS)
 
 ietadm: ietadm.o param.o
-	$(CC) $^ -o $@
+	$(CC) $(LDFLAGS) $^ -o $@
 
 clean:
 	rm -f *.o $(PROGRAMS)
diff -ur iscsitarget-1.4.20.2/usr/config.h iscsitarget-trunk-r453/usr/config.h
--- iscsitarget-1.4.20.2/usr/config.h	2010-03-08 12:15:53.553587000 -0500
+++ iscsitarget-trunk-r453/usr/config.h	2010-09-30 13:44:10.796460000 -0400
@@ -29,7 +29,7 @@
 #define CONFIG_H
 
 struct config_operations {
-	void (*init) (char *, char **, int *);
+	void (*init) (char *params, int *timeout);
 	int (*target_add) (u32 *, char *);
 	int (*target_stop) (u32);
 	int (*target_del) (u32);
diff -ur iscsitarget-1.4.20.2/usr/conn.c iscsitarget-trunk-r453/usr/conn.c
--- iscsitarget-1.4.20.2/usr/conn.c	2010-02-02 14:08:04.758225000 -0500
+++ iscsitarget-trunk-r453/usr/conn.c	2011-02-18 09:54:13.192266000 -0500
@@ -51,7 +51,7 @@
 			      conn->session_param[key_data_digest].val);
 	if (!err)
 		conn->session->conn_cnt++;
-	else if (err < 0 && err != -EEXIST)
+	else
 		log_error("unable to create connection %u for session %#" PRIx64 " in target %u: %d",
 			conn->cid, conn->session->sid.id64, conn->tid, errno);
 
diff -ur iscsitarget-1.4.20.2/usr/event.c iscsitarget-trunk-r453/usr/event.c
--- iscsitarget-1.4.20.2/usr/event.c	2010-06-29 17:59:28.663786000 -0400
+++ iscsitarget-trunk-r453/usr/event.c	2011-02-18 09:54:13.192266000 -0500
@@ -87,10 +87,9 @@
 
 	switch (event.state) {
 	case E_CONN_CLOSE:
-		if (!(session = session_find_id(event.tid, event.sid))) {
-			log_warning("session %llu not found?", event.sid);
-			goto retry;
-		}
+		if (!(session = session_find_id(event.tid, event.sid)))
+			/* session previously closed for reinstatement? */
+			break;
 
 		if (--session->conn_cnt <= 0)
 			session_remove(session);
diff -ur iscsitarget-1.4.20.2/usr/ietd.c iscsitarget-trunk-r453/usr/ietd.c
--- iscsitarget-1.4.20.2/usr/ietd.c	2010-06-30 13:33:57.856517000 -0400
+++ iscsitarget-trunk-r453/usr/ietd.c	2011-01-28 14:56:04.797823000 -0500
@@ -426,6 +426,8 @@
 				pollfd->fd = -1;
 				incoming[i] = NULL;
 				incoming_cnt--;
+				if ((poll_array[POLL_LISTEN].events == 0) && (incoming_cnt < INCOMING_MAX))
+					poll_array[POLL_LISTEN].events = POLLIN;
 				if (session && session->conn_cnt <= 0)
 					session_remove(session);
 			}
@@ -439,8 +441,7 @@
 	char *config = NULL, pid_buf[64];
 	uid_t uid = 0;
 	gid_t gid = 0;
-	char *isns = NULL;
-	int isns_ac = 0, pid_fd;
+	int pid_fd;
 
 	/* otherwise we would die in some later write() during the event_loop
 	 * instead of getting EPIPE! */
@@ -549,10 +550,6 @@
 		exit(-1);
 	}
 
-	cops->init(config, &isns, &isns_ac);
-	if (isns)
-		timeout = isns_init(isns, isns_ac);
-
 	if (gid && setgid(gid) < 0) {
 		log_error("unable to setgid: %m");
 		exit(-1);
@@ -563,6 +560,8 @@
 		exit(-1);
 	}
 
+	cops->init(config, &timeout);
+
 	event_loop(timeout);
 
 	return 0;
diff -ur iscsitarget-1.4.20.2/usr/iscsid.c iscsitarget-trunk-r453/usr/iscsid.c
--- iscsitarget-1.4.20.2/usr/iscsid.c	2010-07-06 16:55:36.469889000 -0400
+++ iscsitarget-trunk-r453/usr/iscsid.c	2011-03-31 12:41:34.114888000 -0400
@@ -273,43 +273,6 @@
 		login_rsp_ini_err(conn, ISCSI_STATUS_AUTH_FAILED);
 }
 
-static void login_security_done(struct connection *conn)
-{
-	struct iscsi_login_req_hdr *req =
-				(struct iscsi_login_req_hdr *)&conn->req.bhs;
-	struct session *session;
-
-	if (!conn->tid)
-		return;
-
-	if ((session = session_find_name(conn->tid, conn->initiator, req->sid))) {
-		if (!req->sid.id.tsih) {
-			/* do session reinstatement */
-			log_debug(1, "session %#" PRIx64 " reinstated",
-								req->sid.id64);
-			if (session_remove(session))
-				login_rsp_tgt_err(conn, ISCSI_STATUS_TARGET_ERROR);
-			return;
-		} else if (req->sid.id.tsih != session->sid.id.tsih) {
-			/* fail the login */
-			login_rsp_ini_err(conn, ISCSI_STATUS_SESSION_NOT_FOUND);
-			return;
-		}
-		/* add connection to existing session */
-		/* reinstatement handled in kernel */
-		log_debug(1, "connection %u added to session %#" PRIx64,
-						conn->cid, req->sid.id64);
-		conn->session = session;
-	} else {
-		if (req->sid.id.tsih) {
-			/* fail the login */
-			login_rsp_ini_err(conn, ISCSI_STATUS_SESSION_NOT_FOUND);
-			return;
-		}
-		/* instantiate a new session */
-	}
-}
-
 static void text_scan_login(struct connection *conn)
 {
 	char *key, *value, *data;
@@ -510,14 +473,43 @@
 
 static void login_finish(struct connection *conn)
 {
+	struct iscsi_login_req_hdr *req =
+			(struct iscsi_login_req_hdr *)&conn->req.bhs;
+	struct session *session =
+			session_find_name(conn->tid, conn->initiator, req->sid);
+
 	switch (conn->session_type) {
 	case SESSION_NORMAL:
+		if (session) {
+			if (!req->sid.id.tsih) {
+				/* session reinstatement */
+				log_debug(1, "session %#" PRIx64 " reinstated",
+					req->sid.id64);
+				if (session_remove(session)) {
+					login_rsp_tgt_err(conn,
+						ISCSI_STATUS_TARGET_ERROR);
+					return;
+				}
+			} else if (req->sid.id.tsih != session->sid.id.tsih) {
+				/* fail the login */
+				login_rsp_ini_err(conn,
+					ISCSI_STATUS_SESSION_NOT_FOUND);
+				return;
+			}
+			/* add connection to existing session */
+			log_debug(1, "connection %u added to session %#" PRIx64,
+				conn->cid, req->sid.id64);
+			conn->session = session;
+		} else if (req->sid.id.tsih) {
+			/* fail the login */
+			login_rsp_ini_err(conn, ISCSI_STATUS_SESSION_NOT_FOUND);
+			return;
+		}
 		/* create or re-create in case the session closed */
 		if (session_create(conn)) {
 			login_rsp_tgt_err(conn, ISCSI_STATUS_TARGET_ERROR);
 			return;
 		}
-		conn->sid = conn->session->sid;
 		break;
 	case SESSION_DISCOVERY:
 		/* set a dummy tsih value */
@@ -680,7 +672,6 @@
 			case STATE_SECURITY:
 			case STATE_SECURITY_DONE:
 				conn->state = STATE_SECURITY_LOGIN;
-				login_security_done(conn);
 				break;
 			default:
 				goto init_err;
@@ -696,7 +687,6 @@
 					break;
 				}
 				conn->state = STATE_SECURITY_FULL;
-				login_security_done(conn);
 				break;
 			case STATE_LOGIN:
 				if (stay)
diff -ur iscsitarget-1.4.20.2/usr/param.c iscsitarget-trunk-r453/usr/param.c
--- iscsitarget-1.4.20.2/usr/param.c	2009-10-08 14:30:14.059052000 -0400
+++ iscsitarget-trunk-r453/usr/param.c	2011-03-31 12:40:11.667295000 -0400
@@ -142,11 +142,15 @@
 {
 	int err = 0;
 
-	if (val & DIGEST_CRC32C)
-		strcpy(str, "CRC32C");
-	else if (val & DIGEST_NONE)
+	if (val & DIGEST_NONE)
 		strcpy(str, "None");
-	else
+	if (val & DIGEST_CRC32C) {
+		if (strlen(str))
+			strcat(str, ",CRC32C");
+		else
+			strcpy(str, "CRC32C");
+	}
+	if (!strlen(str))
 		err = -EINVAL;
 
 	return err;
@@ -158,20 +162,18 @@
 	char *p, *q;
 	p = str;
 
-	*val = DIGEST_NONE;
+	*val = 0;
 	do {
-		if (!strncmp(p, "None", strlen("None")))
+		q = strsep(&p, ",");
+		if (!strcmp(q, "None"))
 			*val |= DIGEST_NONE;
-		else if (!strncmp(p, "CRC32C", strlen("CRC32C")))
+		else if (!strcmp(q, "CRC32C"))
 			*val |= DIGEST_CRC32C;
 		else {
 			err = -EINVAL;
 			break;
 		}
-
-		if ((q = strchr(p, ',')))
-			p = q + 1;
-	} while (q);
+	} while (p);
 
 	return err;
 }
diff -ur iscsitarget-1.4.20.2/usr/plain.c iscsitarget-trunk-r453/usr/plain.c
--- iscsitarget-1.4.20.2/usr/plain.c	2010-03-08 12:15:53.553587000 -0500
+++ iscsitarget-trunk-r453/usr/plain.c	2010-09-30 13:44:10.796460000 -0400
@@ -691,10 +691,12 @@
 	return __plain_param_set(tid, sid, type, 1 << key, param, 0);
 }
 
-static void plain_portal_init(FILE *fp, char **isns, int *isns_ac)
+static void plain_portal_init(FILE *fp, int *timeout)
 {
 	char buf[BUFSIZE];
 	char *p, *q;
+	char *isns = NULL;
+	int isns_ac = 0;
 
 	while (fgets(buf, BUFSIZE, fp)) {
 		q = buf;
@@ -702,15 +704,16 @@
 		if (!p || *p == '#')
 			continue;
 		if (!strcasecmp(p, "iSNSServer")) {
-			*isns = strdup(target_sep_string(&q));
+			isns = strdup(target_sep_string(&q));
 		} else if (!strcasecmp(p, "iSNSAccessControl")) {
 			char *str = target_sep_string(&q);
 			if (!strcasecmp(str, "Yes"))
-				*isns_ac = 1;
+				isns_ac = 1;
 		}
 	}
 
-	return;
+	if (isns)
+		*timeout = isns_init(isns, isns_ac);
 }
 
 static void plain_target_init(FILE *fp)
@@ -796,7 +799,7 @@
 	return;
 }
 
-static void plain_init(char *params, char **isns, int *isns_ac)
+static void plain_init(char *params, int *timeout)
 {
 	FILE *fp;
 	struct stat st;
@@ -826,7 +829,7 @@
 		}
 	}
 
-	plain_portal_init(fp, isns, isns_ac);
+	plain_portal_init(fp, timeout);
 
 	rewind(fp);
 
diff -ur iscsitarget-1.4.20.2/usr/session.c iscsitarget-trunk-r453/usr/session.c
--- iscsitarget-1.4.20.2/usr/session.c	2010-06-30 13:32:55.211309000 -0400
+++ iscsitarget-trunk-r453/usr/session.c	2011-03-31 12:41:34.114888000 -0400
@@ -102,8 +102,10 @@
 		session->initiator = strdup(conn->initiator);
 
 		conn->session = session;
+		conn->sid = session->sid;
 	} else {
 		session = conn->session;
+		conn->sid = session->sid;
 
 		if (session_exist(conn->tid, session->sid.id64))
 			return 0;
diff -ur iscsitarget-1.4.20.2/usr/target.c iscsitarget-trunk-r453/usr/target.c
--- iscsitarget-1.4.20.2/usr/target.c	2010-06-29 17:59:28.663786000 -0400
+++ iscsitarget-trunk-r453/usr/target.c	2011-03-20 12:54:00.726201000 -0400
@@ -78,6 +78,9 @@
 {
 	char taddr[NI_MAXHOST + NI_MAXSERV + 5];
 
+	/* strip ipv6 zone id */
+	addr = strsep(&addr, "%");
+
 	snprintf(taddr, sizeof(taddr),
 		(family == AF_INET) ? "%s:%d,1" : "[%s]:%d,1",
 							addr, server_port);
